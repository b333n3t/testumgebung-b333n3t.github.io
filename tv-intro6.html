<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="robots" content="noindex,follow" />
  <link rel="canonical" href="https://www.b3nn3t.com/" />

  <title>TV-Intro – b3nn3t | Intro-Annimation &amp; Visuals</title>
  <meta name="description" content="Das offizielle Intro von b3nn3t – Sound, Atmosphäre und visuelle Identität. Ein kurzer Einblick in die Welt hinter dem Intro." />

  <script type="speculationrules">
  {
    "prefetch": [{ "source": "document", "urls": ["index.html"] }],
    "prerender": [{ "source": "document", "urls": ["index.html?nointro=1"] }]
  }
  </script>

  <style>
    :root { --fade-ms: 1000ms; --bg:#930010; }

    html,body{
      margin:0;height:100%;
      background:var(--bg);
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    canvas#c{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      display:block;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
      opacity:0;
      transition:opacity var(--fade-ms) ease;
      z-index:1;
    }
    body.ready canvas#c{opacity:1;}
    body.fadeout canvas#c{opacity:0;}

    .skip{
      position:fixed; top:14px; right:14px; z-index:10;
      background:#fff; color:#000; border:0; border-radius:999px;
      padding:.45rem .8rem; font-weight:700; cursor:pointer;
    }
    .skip:focus-visible{outline:2px solid #fff; outline-offset:2px;}

    .loaderWrap{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      opacity:0;
      transition:opacity var(--fade-ms) ease;
      z-index:5;
      pointer-events:none;
    }
    body.ready .loaderWrap{opacity:1;}
    body.fadeout .loaderWrap{opacity:0;}

    .loader{
      width:min(720px,78vw);
      padding:18px 18px 16px;
      box-sizing:border-box;
    }

    .barFrame{
      width:100%; height:16px;
      border:2px solid #fff;
      border-radius:0;
      padding:2px;
      box-sizing:border-box;
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.6),
        inset 0 0 0 1px rgba(0,0,0,0.6);
    }

    .bar{
      height:100%;
      width:0%;
      border-radius:0;
      background:
        repeating-linear-gradient(
          90deg,
          #fff 0px,
          #fff 6px,
          rgba(255,255,255,0.65) 6px,
          rgba(255,255,255,0.65) 8px
        );
    }

    .hint{
      margin-top:10px;
      color:rgba(255,255,255,.9);
      font-size:14px;
      letter-spacing:.2px;
      text-align:center;
      user-select:none;
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
    }

    @media (prefers-reduced-motion: reduce){
      body{animation:none !important;}
      canvas#c,.loaderWrap{transition:none;}
    }
  </style>

  <noscript>
    <meta http-equiv="refresh" content="0; url=index.html?nointro=1">
    <style>
      body{display:flex;align-items:center;justify-content:center;color:#fff;}
      a{color:#fff;text-decoration:underline;}
    </style>
    <p>Weiter zur <a href="index.html?nointro=1">Startseite</a>…</p>
  </noscript>
</head>
<body>

<main role="main">
  <button class="skip" type="button" aria-label="Intro überspringen">Skip</button>
  <canvas id="c" aria-hidden="true"></canvas>

  <div class="loaderWrap" aria-hidden="true">
    <div class="loader">
      <div class="barFrame"><div class="bar" id="bar"></div></div>
      <div class="hint">Loading…</div>
    </div>
  </div>

  <div aria-live="polite" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">
    Intro läuft. Du kannst „Skip“ drücken, um direkt zur Startseite zu wechseln.
  </div>
</main>

<script>
/* ================== Redirect Ziel ================== */
const INTRO_RETURN_URL =
  (sessionStorage.getItem("introReturn") || "index.html") +
  (location.search.includes('nointro=1') ? "" : (location.search ? "&" : "?") + "nointro=1");

/* ================== PRELOAD bleibt drin ================== */
const preloadImages = [
  "assets/index/bennet_index1.avif",
  "assets/index/bennet_index1.webp",
  "assets/index/bennet_index2.avif",
  "assets/index/bennet_index2.webp",
  "assets/index/bennet_index3.avif",
  "assets/index/bennet_index3.webp",

  "assets/gesehen/insta1.webp",
  "assets/gesehen/insta2.webp",
  "assets/gesehen/insta3.webp",
  "assets/gesehen/insta4.webp",

  "assets/gesehen/reel1.avif",
  "assets/gesehen/reel2.avif",
  "assets/gesehen/reel3.avif",
  "assets/gesehen/reel4.avif",
  "assets/gesehen/reel5.avif",
  "assets/gesehen/reel6.avif",
  "assets/gesehen/reel7.avif",
  "assets/gesehen/instagram_poster.jpg",
  "https://img.youtube.com/vi/ZSaj_FuqPN8/hqdefault.jpg",
  "https://img.youtube.com/vi/DMNl40Tip1w/hqdefault.jpg",
  "https://img.youtube.com/vi/K5pKG0Smdfc/hqdefault.jpg",
  "https://img.youtube.com/vi/4I9vlcGvFGQ/hqdefault.jpg",
  "https://img.youtube.com/vi/w0pNdnlb96M/hqdefault.jpg",
  "https://img.youtube.com/vi/rV1U891RKLo/hqdefault.jpg",
  "https://img.youtube.com/vi/fq8zhAQMam0/hqdefault.jpg"
];
const preloadVideos = [ "assets/gesehen/B3NN3T.mp4" ];

function preloadAllImages(urls){
  urls.forEach(url=>{
    const img = new Image();
    img.referrerPolicy = "no-referrer";
    img.src = url;
  });
}
function preloadAllVideos(urls){
  urls.forEach(url=>{
    const v = document.createElement('video');
    v.preload = 'auto';
    v.muted = true;
    v.src = url;
    v.load();
  });
}
if(!window._preloaded){
  window._preloaded=true;
  preloadAllImages(preloadImages);
  preloadAllVideos(preloadVideos);
}

/* ================== Canvas Setup ================== */
const c = document.getElementById('c');
const ctx = c.getContext('2d');

let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  W = c.width  = Math.floor(innerWidth * DPR);
  H = c.height = Math.floor(innerHeight * DPR);
  c.style.width  = innerWidth + 'px';
  c.style.height = innerHeight + 'px';
  ctx.imageSmoothingEnabled = false;
}
addEventListener('resize', resize);
resize();

/* ================== Krakelig Weiß (dünner) ================== */
const snap = (v)=>Math.round(v);
const clamp01 = (t)=>Math.max(0,Math.min(1,t));

function hash01(n){
  const x = Math.sin(n * 127.1) * 43758.5453123;
  return x - Math.floor(x);
}
function smoothstep(t){
  t = clamp01(t);
  return t*t*(3 - 2*t);
}
function noise1D(seed, t){
  const s = t * 12;
  const i = Math.floor(s);
  const f = s - i;
  const a = hash01(seed*1000 + i*17.17);
  const b = hash01(seed*1000 + (i+1)*17.17);
  const u = smoothstep(f);
  return (a*(1-u) + b*u) * 2 - 1;
}

function scribbleStroke(x1,y1,x2,y2,seed,amp){
  const dx = x2-x1, dy = y2-y1;
  const len = Math.hypot(dx,dy) || 1;
  const nx = -dy/len, ny = dx/len;

  const segs = Math.max(10, Math.min(34, Math.floor(len/(14*DPR))));

  ctx.beginPath();
  for(let i=0;i<=segs;i++){
    const t = i/segs;

    let x = x1 + dx*t;
    let y = y1 + dy*t;

    const n  = noise1D(seed, t);
    const n2 = noise1D(seed+9.3, t);

    const mid = smoothstep(t) * (1 - smoothstep(t));
    const a = amp * (0.55 + 1.25*mid);

    x += nx*(n*a) + dx/len*(n2*0.45*DPR);
    y += ny*(n*a) + dy/len*(n2*0.45*DPR);

    x = snap(x); y = snap(y);

    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();
}

function inkLine(x1,y1,x2,y2,seed,amp,alpha){
  ctx.save();
  ctx.globalAlpha = alpha;

  // feiner
  ctx.lineWidth = Math.max(0.75, 0.75 * DPR);
  scribbleStroke(x1,y1,x2,y2,seed,amp);

  // noch feiner + versetzt
  ctx.globalAlpha = alpha*0.65;
  ctx.lineWidth = Math.max(0.65, 0.65 * DPR);
  scribbleStroke(x1+0.35*DPR,y1+0.18*DPR,x2+0.35*DPR,y2+0.18*DPR,seed+111,amp*0.72);

  ctx.restore();
}

/* ================== Buntstift-Kritzel in bestehenden Grid-Flächen ================== */
const COLOR_PENCIL = [
  [255,  80, 190], // pink
  [ 90, 210, 255], // cyan
  [255, 230,  80], // yellow
  [160, 255, 120], // green
  [200, 140, 255], // purple
  [255, 140,  80]  // orange
];

function rngFrom(seed){
  let s = (seed>>>0) || 1;
  return function(){
    s ^= s << 13; s >>>= 0;
    s ^= s >>> 17; s >>>= 0;
    s ^= s << 5;  s >>>= 0;
    return (s>>>0) / 4294967296;
  };
}

function rgbaFrom(rgb, a){
  return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
}

// bilinear mapping in a quad: u (0..1) left->right, v (0..1) near->far (or top->bottom)
function quadPoint(q00,q10,q11,q01,u,v){
  const ax = q00.x + (q10.x - q00.x) * u;
  const ay = q00.y + (q10.y - q00.y) * u;
  const bx = q01.x + (q11.x - q01.x) * u;
  const by = q01.y + (q11.y - q01.y) * u;
  return { x: ax + (bx-ax)*v, y: ay + (by-ay)*v };
}

let colorPatches = []; // stabil (kein flimmern)

function buildColorPatches(seed, RINGS){
  const r = rngFrom(seed);
  const count = 3 + Math.floor(r()*3); // 3..5
  const patches = [];
  for(let i=0;i<count;i++){
    const ring = Math.max(0, Math.min(RINGS-3, Math.floor(r()*(RINGS-2)))); // zwischen ring und ring+1
    const side = Math.floor(r()*4); // 0 top,1 right,2 bottom,3 left
    const col = COLOR_PENCIL[Math.floor(r()*COLOR_PENCIL.length)];
    const alpha = 0.12 + r()*0.18;

    // strokes: nicht voll, nur einige Schraffuren
    const strokesN = 14 + Math.floor(r()*14); // 14..27
    const strokes = [];
    for(let s=0;s<strokesN;s++){
      strokes.push({
        u: r(),                // position in quad
        v: r(),
        len: 0.10 + r()*0.30,  // relative
        ang: (-0.9 + r()*1.8), // -0.9..+0.9 rad (leicht schräg)
        jitter: 0.008 + r()*0.018,
        seed: (seed + i*999 + s*77)>>>0
      });
    }

    patches.push({
      ring, side,
      color: rgbaFrom(col, alpha),
      color2: rgbaFrom(col, alpha*0.55),
      strokes
    });
  }
  return patches;
}

function drawPatchScribble(patch, quad){
  // quad = {a,b,c,d} (im Uhrzeigersinn)
  const a=quad.a, b=quad.b, c=quad.c, d=quad.d;

  // Clip auf Fläche
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(a.x,a.y);
  ctx.lineTo(b.x,b.y);
  ctx.lineTo(c.x,c.y);
  ctx.lineTo(d.x,d.y);
  ctx.closePath();
  ctx.clip();

  // leichte "Papier"-Überlagerung durch 2 Passes
  for(let pass=0; pass<2; pass++){
    ctx.strokeStyle = (pass===0) ? patch.color : patch.color2;
    for(let i=0;i<patch.strokes.length;i++){
      const st = patch.strokes[i];

      // Ausgangspunkt im Quad
      const p0 = quadPoint(a,b,c,d, st.u, st.v);

      // Richtung: angle im lokalen Screen, plus bisschen random
      const r = rngFrom(st.seed + pass*999);
      const ang = st.ang + (r()-0.5)*0.35;

      // Länge in Pixel (abhängig von Quad-Größe)
      const w = Math.hypot(b.x-a.x, b.y-a.y);
      const h = Math.hypot(d.x-a.x, d.y-a.y);
      const L = st.len * Math.max(28*DPR, Math.min(w,h));

      const x1 = p0.x;
      const y1 = p0.y;
      const x2 = p0.x + Math.cos(ang)*L;
      const y2 = p0.y + Math.sin(ang)*L;

      // Kritzel: feiner als Grid
      const amp = (1.1 + (r()*0.7)) * DPR;
      const alpha = 0.55;

      // pass 0 und pass 1 leicht versetzt, damit “Buntstift” wirkt
      if(pass===0){
        inkLine(x1,y1,x2,y2, st.seed, amp, alpha*0.55);
      } else {
        inkLine(x1+0.25*DPR,y1+0.18*DPR,x2+0.25*DPR,y2+0.18*DPR, st.seed+333, amp*0.85, alpha*0.40);
      }
    }
  }

  ctx.restore();
}

/* ================== Tunnel-Grid (weiß, dünner, krakelig) ================== */
function drawTunnelGrid(now, reveal01){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#930010';
  ctx.fillRect(0,0,W,H);

  const outer = [
    {x:0, y:0}, {x:W, y:0}, {x:W, y:H}, {x:0, y:H}
  ];

  const cx = W*0.5, cy = H*0.5;
  const innerW = W*0.44;
  const innerH = H*0.32;
  const inner = [
    {x:cx - innerW/2, y:cy - innerH/2},
    {x:cx + innerW/2, y:cy - innerH/2},
    {x:cx + innerW/2, y:cy + innerH/2},
    {x:cx - innerW/2, y:cy + innerH/2}
  ];

  const lerp = (a,b,t)=>a+(b-a)*t;
  const lerpP = (A,B,t)=>({ x: lerp(A.x,B.x,t), y: lerp(A.y,B.y,t) });

  const RINGS = 34;
  const RAD   = 26;
  const ringCount = Math.max(1, Math.floor(reveal01 * RINGS));
  const radCount  = Math.max(2, Math.floor(reveal01 * RAD));

  const speed = 0.00038;
  const phase = (now*speed) % 1;

  ctx.strokeStyle = 'rgba(255,255,255,0.52)';

  const AMP = 3.0 * DPR;
  const AMP_RING = AMP * 0.92;
  const AMP_RAD  = AMP * 1.00;

  // Radials
  for(let i=0;i<=radCount;i++){
    const t = i/radCount;

    const A = { x: lerp(outer[0].x, outer[1].x, t), y: outer[0].y };
    const B = { x: lerp(inner[0].x, inner[1].x, t), y: inner[0].y };
    inkLine(A.x,A.y,B.x,B.y, 10+i*0.13, AMP_RAD, 0.50);

    const C = { x: lerp(outer[3].x, outer[2].x, t), y: outer[3].y };
    const D = { x: lerp(inner[3].x, inner[2].x, t), y: inner[3].y };
    inkLine(C.x,C.y,D.x,D.y, 20+i*0.13, AMP_RAD, 0.50);
  }
  for(let i=0;i<=radCount;i++){
    const t = i/radCount;

    const A = { x: outer[0].x, y: lerp(outer[0].y, outer[3].y, t) };
    const B = { x: inner[0].x, y: lerp(inner[0].y, inner[3].y, t) };
    inkLine(A.x,A.y,B.x,B.y, 30+i*0.13, AMP_RAD, 0.50);

    const C = { x: outer[1].x, y: lerp(outer[1].y, outer[2].y, t) };
    const D = { x: inner[1].x, y: lerp(inner[1].y, inner[2].y, t) };
    inkLine(C.x,C.y,D.x,D.y, 40+i*0.13, AMP_RAD, 0.50);
  }

  // Helper: ring points at a given z
  function ringPointsAt(z){
    return {
      q0: lerpP(outer[0], inner[0], z),
      q1: lerpP(outer[1], inner[1], z),
      q2: lerpP(outer[2], inner[2], z),
      q3: lerpP(outer[3], inner[3], z),
    };
  }

  // Rings + (optional) farbige Kritzel-Patches in Flächen
  // Wir brauchen die Ring-Geometrie auch für die Patches:
  // -> Patches referenzieren ring i und ring i+1 und eine Seite (top/right/bottom/left)
  // -> dadurch entstehen exakt die “Rechtecke/Flächen” im Grid.
  const ringZ = [];
  for(let i=0;i<ringCount;i++){
    const u = (i/(RINGS-1));
    let z = u*u;
    z = (z + phase*0.22) % 1;
    z = z*z;
    ringZ.push(z);

    const P = ringPointsAt(z);
    const front = (1 - z);
    const alpha = 0.10 + 0.22*front;
    const a = AMP_RING * (0.55 + 0.70*front);

    inkLine(P.q0.x,P.q0.y,P.q1.x,P.q1.y, 100+i*0.21, a, alpha);
    inkLine(P.q1.x,P.q1.y,P.q2.x,P.q2.y, 200+i*0.21, a, alpha);
    inkLine(P.q2.x,P.q2.y,P.q3.x,P.q3.y, 300+i*0.21, a, alpha);
    inkLine(P.q3.x,P.q3.y,P.q0.x,P.q0.y, 400+i*0.21, a, alpha);
  }

  // Portal
  inkLine(inner[0].x,inner[0].y,inner[1].x,inner[1].y, 900, AMP*1.05, 0.62);
  inkLine(inner[1].x,inner[1].y,inner[2].x,inner[2].y, 901, AMP*1.05, 0.62);
  inkLine(inner[2].x,inner[2].y,inner[3].x,inner[3].y, 902, AMP*1.05, 0.62);
  inkLine(inner[3].x,inner[3].y,inner[0].x,inner[0].y, 903, AMP*1.05, 0.62);

  // ✅ Farb-Kritzel in ausgewählten Grid-Flächen
  // erscheinen sanft erst nach etwas Zeit
  const paintAlpha = Math.min(1, Math.max(0, (reveal01 - 0.18) / 0.82));
  if(colorPatches.length && ringZ.length >= 3 && paintAlpha > 0){
    ctx.save();
    ctx.globalAlpha = paintAlpha;

    for(const patch of colorPatches){
      const i = Math.max(0, Math.min(ringZ.length-2, patch.ring));
      const zA = ringZ[i];
      const zB = ringZ[i+1];

      const A = ringPointsAt(zA);
      const B = ringPointsAt(zB);

      // Side -> quad zwischen Ring i und i+1
      let quad;
      if(patch.side === 0){ // top: q0-q1
        quad = { a:A.q0, b:A.q1, c:B.q1, d:B.q0 };
      } else if(patch.side === 1){ // right: q1-q2
        quad = { a:A.q1, b:A.q2, c:B.q2, d:B.q1 };
      } else if(patch.side === 2){ // bottom: q3-q2 (umdrehen für cw)
        quad = { a:A.q3, b:A.q2, c:B.q2, d:B.q3 };
      } else { // left: q0-q3
        quad = { a:A.q0, b:A.q3, c:B.q3, d:B.q0 };
      }

      drawPatchScribble(patch, quad);
    }

    ctx.restore();
  }
}

/* ================== Loader Timing ================== */
const START_DELAY_MS = 1000;
const INTRO_MS = 3500;
const FADEOUT_MS = 1700;
const EXTRA_MS = 300;

let rafId = null;

function startTransition(){
  sessionStorage.setItem("introPlayed","1");
  document.body.classList.add('fadeout');
  setTimeout(()=>{ window.location.href = INTRO_RETURN_URL; }, FADEOUT_MS + EXTRA_MS);
}

function startProgressAndTunnel(){
  const bar = document.getElementById('bar');
  const start = performance.now();

  // ✅ Patches 1x generieren (stabil, kein Flimmern)
  const seed = (((start|0) ^ (W<<1) ^ (H<<2)) >>> 0) || 12345;
  colorPatches = buildColorPatches(seed, 34);

  function frame(now){
    const t = (now - start) / INTRO_MS;
    const clamped = Math.max(0, Math.min(1, t));
    const reveal = Math.min(1, clamped * 1.20);

    drawTunnelGrid(now, reveal);

    const steps = 32;
    const stepped = Math.floor(clamped * steps) / steps;
    bar.style.width = (stepped * 100).toFixed(2) + "%";

    if(clamped >= 1){
      bar.style.width = "100%";
      startTransition();
      return;
    }
    rafId = requestAnimationFrame(frame);
  }
  rafId = requestAnimationFrame(frame);
}

/* ================== Skip & A11y ================== */
(function setupSkipAndA11y(){
  const skipBtn = document.querySelector('.skip');
  function goNow(){
    try { sessionStorage.setItem("introPlayed","1"); } catch(e){}
    document.body.classList.add('fadeout');
    setTimeout(()=>location.replace(INTRO_RETURN_URL), 250);
  }
  if (skipBtn) skipBtn.addEventListener('click', goNow);

  try {
    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      goNow();
      return;
    }
  } catch(e){}
})();

/* ================== Start ================== */
setTimeout(() => {
  document.body.classList.add('ready');
  startProgressAndTunnel();
}, START_DELAY_MS);
</script>
</body>
</html>
