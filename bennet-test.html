<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ✅ SEO: Intro soll nicht indexiert werden -->
  <meta name="robots" content="noindex,follow" />
  <!-- ✅ Canonical auf die eigentliche Startseite -->
  <link rel="canonical" href="https://www.b3nn3t.com/" />

  <title>TV-Intro – b3nn3t | Intro-Annimation &amp; Visuals</title>
  <meta name="description" content="Das offizielle Intro von b3nn3t – Sound, Atmosphäre und visuelle Identität. Ein kurzer Einblick in die Welt hinter dem Intro." />

  <!-- (Optional) Spekulations-Regeln: Startseite vorladen/prerendern -->
  <script type="speculationrules">
  {
    "prefetch": [{ "source": "document", "urls": ["index.html"] }],
    "prerender": [{ "source": "document", "urls": ["index.html?nointro=1"] }]
  }
  </script>

  <style>
    :root{
      --bg: #930010;
      --white: #ffffff;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
      font-family: Arial, Helvetica, sans-serif;
    }

    /* Fullscreen Canvas */
    #scribbleCanvas{
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      z-index: 1;
    }

    /* Loader UI */
    .center {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
      pointer-events: none;
    }

    .loader-wrap { width: min(360px, 80vw); }
    .loader-border {
      height: 18px;
      border: 2px solid var(--white);
      box-sizing: border-box;
      background: transparent;
    }
    .loader-bar {
      height: 100%;
      width: 0%;
      background: var(--white);
      animation: loading 3.5s ease-in-out forwards;
    }
    @keyframes loading {
      from { width: 0%; }
      to   { width: 100%; }
    }
  </style>
</head>

<body>
  <canvas id="scribbleCanvas"></canvas>

  <div class="center">
    <div class="loader-wrap">
      <div class="loader-border">
        <div class="loader-bar"></div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("scribbleCanvas");
    const ctx = canvas.getContext("2d", { alpha: true });

    function resizeCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width  = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      paintBackground();
    }

    window.addEventListener("resize", resizeCanvas);

    function paintBackground() {
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "#930010";
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    }

    function rand(min, max) { return Math.random() * (max - min) + min; }

    // Bunte Farbstift-Palette (kräftig, gut sichtbar auf rot)
    const palette = [
      "#ffffff", "#00e5ff", "#00ff6a", "#ffe600",
      "#ff7a00", "#ff2bd6", "#7c5cff", "#2bfffa",
      "#ffd1f5", "#a9ff00", "#ffb3a7", "#7dffb2"
    ];

    function randomEdgeStart() {
      const w = window.innerWidth, h = window.innerHeight;
      const side = Math.floor(rand(0, 4)); // 0 top, 1 right, 2 bottom, 3 left
      if (side === 0) return { x: rand(0, w), y: -20 };
      if (side === 1) return { x: w + 20, y: rand(0, h) };
      if (side === 2) return { x: rand(0, w), y: h + 20 };
      return { x: -20, y: rand(0, h) };
    }

    // Farbstift-Look: Linie wird in mehreren "weichen" Layern gezeichnet + leichte Körnung
    function drawPencilStroke(x1, y1, x2, y2, color, baseWidth) {
      ctx.globalCompositeOperation = "source-over";
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      // Hauptstrich (dicker, kräftig)
      ctx.strokeStyle = hexToRgba(color, 0.65);
      ctx.lineWidth = baseWidth;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      // 2–4 zusätzliche "Faser"-Striche leicht versetzt (gibt Farbstift-Textur)
      const fibers = Math.floor(rand(2, 5));
      for (let i = 0; i < fibers; i++) {
        const ox1 = x1 + rand(-2.5, 2.5);
        const oy1 = y1 + rand(-2.5, 2.5);
        const ox2 = x2 + rand(-2.5, 2.5);
        const oy2 = y2 + rand(-2.5, 2.5);

        ctx.strokeStyle = hexToRgba(color, rand(0.12, 0.28));
        ctx.lineWidth = Math.max(1, baseWidth * rand(0.35, 0.65));
        ctx.beginPath();
        ctx.moveTo(ox1, oy1);
        ctx.lineTo(ox2, oy2);
        ctx.stroke();
      }

      // Leichte Körnung als Punkte entlang der Strecke (Papier/Farbstift-Effekt)
      const steps = Math.floor(rand(6, 14));
      for (let s = 0; s < steps; s++) {
        const t = s / steps;
        const px = x1 + (x2 - x1) * t + rand(-1.8, 1.8);
        const py = y1 + (y2 - y1) * t + rand(-1.8, 1.8);

        ctx.fillStyle = hexToRgba(color, rand(0.10, 0.20));
        const r = rand(0.6, 1.4);
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function hexToRgba(hex, a) {
      const h = hex.replace("#", "").trim();
      const full = h.length === 3
        ? h.split("").map(ch => ch + ch).join("")
        : h;
      const r = parseInt(full.slice(0, 2), 16);
      const g = parseInt(full.slice(2, 4), 16);
      const b = parseInt(full.slice(4, 6), 16);
      return `rgba(${r},${g},${b},${a})`;
    }

    // Kritzel-Agents
    const agents = [];
    const AGENT_COUNT = 18;     // weniger Agents, aber dickere, prägnantere Striche
    const SPEED_MIN = 5.0;
    const SPEED_MAX = 12.0;

    function makeAgent() {
      const p = randomEdgeStart();
      const angle = rand(0, Math.PI * 2);
      const speed = rand(SPEED_MIN, SPEED_MAX);

      const color = palette[Math.floor(rand(0, palette.length))];

      return {
        x: p.x, y: p.y,
        px: p.x, py: p.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        jitter: rand(0.8, 2.0),
        turn: rand(0.05, 0.16),
        width: rand(7, 16),           // deutlich grösser
        color,
        life: Math.floor(rand(260, 650))
      };
    }

    function init() {
      resizeCanvas();
      agents.length = 0;
      for (let i = 0; i < AGENT_COUNT; i++) agents.push(makeAgent());
    }

    init();

    // Wichtig: KEIN Fade/Overdraw über die ganze Fläche => Verlauf bleibt sichtbar
    // (Wir zeichnen nur weiter drüber, wie auf Papier)
    function step() {
      const w = window.innerWidth, h = window.innerHeight;

      for (let i = 0; i < agents.length; i++) {
        const a = agents[i];

        a.px = a.x; a.py = a.y;

        // starke Richtungswechsel (wild)
        a.vx += rand(-a.turn, a.turn) * 16;
        a.vy += rand(-a.turn, a.turn) * 16;

        // Geschwindigkeit begrenzen
        const sp = Math.hypot(a.vx, a.vy) || 1;
        const maxSp = SPEED_MAX;
        if (sp > maxSp) {
          a.vx = (a.vx / sp) * maxSp;
          a.vy = (a.vy / sp) * maxSp;
        }

        // Bewegung + jitter
        a.x += a.vx + rand(-a.jitter, a.jitter);
        a.y += a.vy + rand(-a.jitter, a.jitter);

        // Zeichnen
        drawPencilStroke(a.px, a.py, a.x, a.y, a.color, a.width);

        // Lebenszeit
        a.life -= 1;

        // neu starten, wenn fertig oder ausserhalb
        if (a.life <= 0 || a.x < -120 || a.x > w + 120 || a.y < -120 || a.y > h + 120) {
          agents[i] = makeAgent();
        }
      }

      requestAnimationFrame(step);
    }

    requestAnimationFrame(step);

    // Optional: mit Taste "R" alles löschen und neu starten
    window.addEventListener("keydown", (e) => {
      if (e.key === "r" || e.key === "R") {
        paintBackground();
        for (let i = 0; i < agents.length; i++) agents[i] = makeAgent();
      }
    });
  </script>
</body>
</html>
