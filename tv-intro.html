<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="robots" content="noindex,follow" />
  <link rel="canonical" href="https://www.b3nn3t.com/" />

  <title>TV-Intro – b3nn3t | Intro-Annimation &amp; Visuals</title>
  <meta name="description" content="Das offizielle Intro von b3nn3t – Sound, Atmosphäre und visuelle Identität. Ein kurzer Einblick in die Welt hinter dem Intro." />

  <script type="speculationrules">
  {
    "prefetch": [{ "source": "document", "urls": ["index.html"] }],
    "prerender": [{ "source": "document", "urls": ["index.html?nointro=1"] }]
  }
  </script>

  <style>
    :root {
      --fade-ms: 1000ms;
      --bg: #930010;
    }

    html,body {
      margin:0;
      height:100%;
      background:var(--bg);
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    canvas#c{
      position:fixed;
      inset:0;
      display:block;
      width:100vw;
      height:100vh;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
      opacity:0;
      transition: opacity var(--fade-ms) ease;
      z-index:1;
    }
    body.ready canvas#c  { opacity:1; }
    body.fadeout canvas#c{ opacity:0; }

    .skip {
      position:fixed; top:14px; right:14px; z-index:10;
      background:#fff; color:#000; border:0; border-radius:999px;
      padding:.45rem .8rem; font-weight:700; cursor:pointer;
    }
    .skip:focus-visible { outline:2px solid #fff; outline-offset:2px; }

    .loaderWrap{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:0;
      transition: opacity var(--fade-ms) ease;
      z-index:5;
      pointer-events:none;
    }
    body.ready .loaderWrap{ opacity:1; }
    body.fadeout .loaderWrap{ opacity:0; }

    .loader{
      width:min(720px, 78vw);
      padding:18px 18px 16px;
      box-sizing:border-box;
    }

    .barFrame{
      width:100%;
      height:16px;
      border:2px solid #fff;
      border-radius:0;
      padding:2px;
      box-sizing:border-box;
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.6),
        inset 0 0 0 1px rgba(0,0,0,0.6);
    }

    .bar{
      height:100%;
      width:0%;
      border-radius:0;
      background:
        repeating-linear-gradient(
          90deg,
          #fff 0px,
          #fff 6px,
          rgba(255,255,255,0.65) 6px,
          rgba(255,255,255,0.65) 8px
        );
    }

    .hint{
      margin-top:10px;
      color:rgba(255,255,255,.85);
      font-size:14px;
      letter-spacing:.2px;
      text-align:center;
      user-select:none;
    }

    @media (prefers-reduced-motion: reduce) {
      body { animation:none !important; }
      canvas#c, .loaderWrap { transition:none; }
    }
  </style>

  <noscript>
    <meta http-equiv="refresh" content="0; url=index.html?nointro=1">
    <style>
      body { display:flex; align-items:center; justify-content:center; color:#fff; }
      a { color:#fff; text-decoration:underline; }
    </style>
    <p>Weiter zur <a href="index.html?nointro=1">Startseite</a>…</p>
  </noscript>
</head>
<body>

  <main role="main">
    <button class="skip" type="button" aria-label="Intro überspringen">Skip</button>

    <canvas id="c" aria-hidden="true"></canvas>

    <div class="loaderWrap" aria-hidden="true">
      <div class="loader">
        <div class="barFrame">
          <div class="bar" id="bar"></div>
        </div>
        <div class="hint">Loading…</div>
      </div>
    </div>

    <div aria-live="polite" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">
      Intro läuft. Du kannst „Skip“ drücken, um direkt zur Startseite zu wechseln.
    </div>
  </main>

<script>
/* ================== Redirect Ziel ================== */
const INTRO_RETURN_URL =
  (sessionStorage.getItem("introReturn") || "index.html") +
  (location.search.includes('nointro=1') ? "" : (location.search ? "&" : "?") + "nointro=1");

/* ================== PRELOAD bleibt drin ================== */
const preloadImages = [
  "assets/index/bennet_index1.avif",
  "assets/index/bennet_index1.webp",
  "assets/index/bennet_index2.avif",
  "assets/index/bennet_index2.webp",
  "assets/index/bennet_index3.avif",
  "assets/index/bennet_index3.webp",

  "assets/gesehen/insta1.webp",
  "assets/gesehen/insta2.webp",
  "assets/gesehen/insta3.webp",
  "assets/gesehen/insta4.webp",

  "assets/gesehen/reel1.avif",
  "assets/gesehen/reel2.avif",
  "assets/gesehen/reel3.avif",
  "assets/gesehen/reel4.avif",
  "assets/gesehen/reel5.avif",
  "assets/gesehen/reel6.avif",
  "assets/gesehen/reel7.avif",
  "assets/gesehen/instagram_poster.jpg",
  "https://img.youtube.com/vi/ZSaj_FuqPN8/hqdefault.jpg",
  "https://img.youtube.com/vi/DMNl40Tip1w/hqdefault.jpg",
  "https://img.youtube.com/vi/K5pKG0Smdfc/hqdefault.jpg",
  "https://img.youtube.com/vi/4I9vlcGvFGQ/hqdefault.jpg",
  "https://img.youtube.com/vi/w0pNdnlb96M/hqdefault.jpg",
  "https://img.youtube.com/vi/rV1U891RKLo/hqdefault.jpg",
  "https://img.youtube.com/vi/fq8zhAQMam0/hqdefault.jpg"
];
const preloadVideos = [ "assets/gesehen/B3NN3T.mp4" ];

function preloadAllImages(urls){
  urls.forEach(url=>{
    const img = new Image();
    img.referrerPolicy = "no-referrer";
    img.src = url;
  });
}
function preloadAllVideos(urls){
  urls.forEach(url=>{
    const v = document.createElement('video');
    v.preload = 'auto';
    v.muted = true;
    v.src = url;
    v.load();
  });
}
if(!window._preloaded){
  window._preloaded=true;
  preloadAllImages(preloadImages);
  preloadAllVideos(preloadVideos);
}

/* ================== Canvas Setup ================== */
const c = document.getElementById('c');
const ctx = c.getContext('2d');

let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  W = c.width  = Math.floor(innerWidth * DPR);
  H = c.height = Math.floor(innerHeight * DPR);
  c.style.width  = innerWidth + 'px';
  c.style.height = innerHeight + 'px';
  ctx.imageSmoothingEnabled = false;
}
addEventListener('resize', resize);
resize();

/* ================== "Hand-drawn" Helpers (deterministisch, kein Flimmern) ================== */
const snap = (v)=>Math.round(v);

// schneller Hash -> 0..1
function hash01(n){
  // deterministic pseudo-random
  const x = Math.sin(n * 127.1) * 43758.5453123;
  return x - Math.floor(x);
}

// glatter Wert (0..1) über "t" (damit Linien nicht hart knicken)
function smoothstep(t){
  t = Math.max(0, Math.min(1, t));
  return t*t*(3 - 2*t);
}

// krakelige Linie als Polyline mit kleinen Perp-Offsets
function scribbleLine(x1,y1,x2,y2,seed,ampPx, wobbleNow){
  // wobbleNow: kleiner Drift, aber stabil (kein jitter)
  const dx = x2-x1, dy = y2-y1;
  const len = Math.hypot(dx,dy) || 1;
  const nx = -dy/len, ny = dx/len; // perpendicular

  // Segmente abhängig von Länge (aber gedeckelt)
  const segs = Math.max(6, Math.min(18, Math.floor(len / (28*DPR))));

  ctx.beginPath();

  for(let i=0;i<=segs;i++){
    const t = i / segs;

    // Basis-Punkt
    let x = x1 + dx*t;
    let y = y1 + dy*t;

    // deterministisches "Hand"-Offset pro Segment
    const r = (hash01(seed*1000 + i*17.7) * 2 - 1);     // -1..1
    const r2 = (hash01(seed*2000 + i*9.3) * 2 - 1);    // -1..1

    // sanft zur Mitte stärker, an Enden weniger
    const m = smoothstep(t) * (1 - smoothstep(t));
    const a = ampPx * (0.55 + 0.45*m);

    // leichter zeitlicher Drift (wie "Hand bewegt sich"), aber gleichmäßig
    const drift = Math.sin(wobbleNow + seed*3.1 + i*0.7) * (0.25*DPR);

    x += nx * (r*a + drift) + (r2*0.35*DPR);
    y += ny * (r*a + drift) + (r2*0.35*DPR);

    if(i===0) ctx.moveTo(snap(x), snap(y));
    else      ctx.lineTo(snap(x), snap(y));
  }

  ctx.stroke();
}

/* ================== Tunnel-Grid (4 Seiten, "Raum" in der Mitte) ================== */
function drawTunnelGrid(now, reveal01){
  // background
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#930010';
  ctx.fillRect(0,0,W,H);

  // Stil
  ctx.save();
  ctx.lineWidth = Math.max(1, Math.round(DPR));
  ctx.strokeStyle = 'rgba(0,0,0,0.30)';

  // Outer quad
  const outer = [
    {x:0, y:0}, {x:W, y:0}, {x:W, y:H}, {x:0, y:H}
  ];

  // Inner quad (Portal)
  const cx = W*0.5, cy = H*0.5;
  const innerW = W*0.42;
  const innerH = H*0.30;

  const inner = [
    {x:cx - innerW/2, y:cy - innerH/2},
    {x:cx + innerW/2, y:cy - innerH/2},
    {x:cx + innerW/2, y:cy + innerH/2},
    {x:cx - innerW/2, y:cy + innerH/2}
  ];

  const lerp = (a,b,t)=>a+(b-a)*t;
  const lerpP = (A,B,t)=>({ x: lerp(A.x,B.x,t), y: lerp(A.y,B.y,t) });

  // counts
  const RINGS = 30;
  const RAD   = 22;
  const ringCount = Math.max(1, Math.floor(reveal01 * RINGS));
  const radCount  = Math.max(2, Math.floor(reveal01 * RAD));

  // Bewegung (stabil)
  const speed = 0.00035;
  const phase = (now*speed) % 1;
  const wobbleNow = now * 0.002; // für hand-drift, aber smooth

  // Hand-Parameter
  const baseAmp = 1.6 * DPR; // "wie krakelig" (erhöhe für mehr Hand-Look)

  // --- 1) Radiale Linien von allen 4 Seiten ---
  // Oben + Unten
  for(let i=0;i<=radCount;i++){
    const t = i / radCount;

    // oben
    const A = { x: lerp(outer[0].x, outer[1].x, t), y: outer[0].y };
    const B = { x: lerp(inner[0].x, inner[1].x, t), y: inner[0].y };
    scribbleLine(A.x,A.y,B.x,B.y, 10 + i*0.11, baseAmp, wobbleNow);

    // unten
    const C = { x: lerp(outer[3].x, outer[2].x, t), y: outer[3].y };
    const D = { x: lerp(inner[3].x, inner[2].x, t), y: inner[3].y };
    scribbleLine(C.x,C.y,D.x,D.y, 20 + i*0.11, baseAmp, wobbleNow);
  }

  // Links + Rechts
  for(let i=0;i<=radCount;i++){
    const t = i / radCount;

    // links
    const A = { x: outer[0].x, y: lerp(outer[0].y, outer[3].y, t) };
    const B = { x: inner[0].x, y: lerp(inner[0].y, inner[3].y, t) };
    scribbleLine(A.x,A.y,B.x,B.y, 30 + i*0.11, baseAmp, wobbleNow);

    // rechts
    const C = { x: outer[1].x, y: lerp(outer[1].y, outer[2].y, t) };
    const D = { x: inner[1].x, y: lerp(inner[1].y, inner[2].y, t) };
    scribbleLine(C.x,C.y,D.x,D.y, 40 + i*0.11, baseAmp, wobbleNow);
  }

  // --- 2) Tiefen-Ringe (Quads) ---
  for(let i=0;i<ringCount;i++){
    const u = (i / (RINGS-1));

    let z = u*u;                 // dichter zum Zentrum
    z = (z + phase*0.18) % 1;    // Bewegung nach vorne
    z = z*z;

    const q0 = lerpP(outer[0], inner[0], z);
    const q1 = lerpP(outer[1], inner[1], z);
    const q2 = lerpP(outer[2], inner[2], z);
    const q3 = lerpP(outer[3], inner[3], z);

    // weiter hinten weniger "Hand", vorne etwas mehr
    const depthAmp = baseAmp * (0.65 + 0.55*(1 - z));

    scribbleLine(q0.x,q0.y,q1.x,q1.y, 100 + i*0.21, depthAmp, wobbleNow);
    scribbleLine(q1.x,q1.y,q2.x,q2.y, 200 + i*0.21, depthAmp, wobbleNow);
    scribbleLine(q2.x,q2.y,q3.x,q3.y, 300 + i*0.21, depthAmp, wobbleNow);
    scribbleLine(q3.x,q3.y,q0.x,q0.y, 400 + i*0.21, depthAmp, wobbleNow);
  }

  // Inneres Frame etwas kräftiger
  ctx.strokeStyle = 'rgba(0,0,0,0.45)';
  const portalAmp = baseAmp * 1.2;
  scribbleLine(inner[0].x,inner[0].y,inner[1].x,inner[1].y, 900, portalAmp, wobbleNow);
  scribbleLine(inner[1].x,inner[1].y,inner[2].x,inner[2].y, 901, portalAmp, wobbleNow);
  scribbleLine(inner[2].x,inner[2].y,inner[3].x,inner[3].y, 902, portalAmp, wobbleNow);
  scribbleLine(inner[3].x,inner[3].y,inner[0].x,inner[0].y, 903, portalAmp, wobbleNow);

  ctx.restore();
}

/* ================== Loader Timing ================== */
const START_DELAY_MS = 1000;
const INTRO_MS = 3500;   // ✅ 3–4 Sekunden => 3.5s
const FADEOUT_MS = 1700;
const EXTRA_MS = 300;

let rafId = null;

function startTransition(){
  sessionStorage.setItem("introPlayed","1");
  document.body.classList.add('fadeout');
  setTimeout(()=>{ window.location.href = INTRO_RETURN_URL; }, FADEOUT_MS + EXTRA_MS);
}

function startProgressAndTunnel(){
  const bar = document.getElementById('bar');
  const start = performance.now();

  function frame(now){
    const t = (now - start) / INTRO_MS;
    const clamped = Math.max(0, Math.min(1, t));

    // "Strich-für-Strich" Aufbau
    const reveal = Math.min(1, clamped * 1.15);

    // Tunnel zeichnen
    drawTunnelGrid(now, reveal);

    // Arcade-Steps
    const steps = 32;
    const stepped = Math.floor(clamped * steps) / steps;
    bar.style.width = (stepped * 100).toFixed(2) + "%";

    if(clamped >= 1){
      bar.style.width = "100%";
      startTransition();
      return;
    }
    rafId = requestAnimationFrame(frame);
  }
  rafId = requestAnimationFrame(frame);
}

/* ================== Skip & A11y ================== */
(function setupSkipAndA11y(){
  const skipBtn = document.querySelector('.skip');
  function goNow(){
    try { sessionStorage.setItem("introPlayed","1"); } catch(e){}
    document.body.classList.add('fadeout');
    setTimeout(()=>location.replace(INTRO_RETURN_URL), 250);
  }
  if (skipBtn) skipBtn.addEventListener('click', goNow);

  try {
    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      goNow();
      return;
    }
  } catch(e){}
})();

/* ================== Start ================== */
setTimeout(() => {
  document.body.classList.add('ready');
  startProgressAndTunnel();
}, START_DELAY_MS);
</script>
</body>
</html>
